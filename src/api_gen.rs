/* Code generated by codegen/main.go. DO NOT EDIT. */

use std::collections::HashMap;
use std::fmt::{Display, Formatter, Write};

use nanoserde::{DeJson, SerJson};
use serde::{Deserialize, Serialize};
use urlencoding::encode;

#[derive(Debug, Clone)]
pub enum Authentication {
    Basic { username: String, password: String },
    Bearer { token: String },
}

#[derive(Debug, Clone, PartialEq, Copy)]
pub enum Method {
    Post,
    Get,
    Put,
    Delete,
}

#[derive(Debug, Clone)]
pub struct RestRequest<Response> {
    pub authentication: Authentication,
    pub urlpath: String,
    pub query_params: String,
    pub body: String,
    pub method: Method,
    _marker: std::marker::PhantomData<Response>,
}

/// A single user-role pair.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct GroupUserListGroupUser {
    pub state: i32,
    pub user: ApiUser,
}

/// A single group-role pair.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct UserGroupListUserGroup {
    pub group: ApiGroup,
    pub state: i32,
}

/// - UNKNOWN: Unknown environment.  - SANDBOX: Sandbox/test environment.  - PRODUCTION: Production environment.
#[derive(Debug, Clone, Copy)]
#[repr(i32)]
pub enum ValidatedPurchaseEnvironment {
    /// - UNKNOWN: Unknown environment.
    UNKNOWN = 0,
    ///  - SANDBOX: Sandbox/test environment.
    SANDBOX = 1,
    ///  - PRODUCTION: Production environment.
    PRODUCTION = 2,
}

/// - AppleAppStore: Apple App Store  - GooglePlayStore: Google Play Store  - HuaweiAppGallery: Huawei App Gallery
#[derive(Debug, Clone, Copy)]
#[repr(i32)]
pub enum ValidatedPurchaseStore {
    /// - AppleAppStore: Apple App Store
    AppleAppStore = 0,
    ///  - GooglePlayStore: Google Play Store
    GooglePlayStore = 1,
    ///  - HuaweiAppGallery: Huawei App Gallery
    HuaweiAppGallery = 2,
}

/// Record values to write.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct WriteLeaderboardRecordRequestLeaderboardRecordWrite {
    pub metadata: String,
    pub operator: ApiOverrideOperator,
    pub score: String,
    pub subscore: Option<String>,
}

#[derive(Debug, DeJson, SerJson, Default, Clone)]
pub struct CreateLeaderboard{
    pub operator: String,
}

#[derive(Debug, DeJson, SerJson, Default, Clone)]
pub struct CreateLeaderboardRes{
    pub payload: String,
}

#[derive(Debug, Deserialize, Serialize, DeJson, SerJson, Default, Clone)]
pub struct Leaderboard{
    pub leaderboard_id: String,
}

/// Record values to write.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct WriteTournamentRecordRequestTournamentRecordWrite {
    pub metadata: Option<String>,
    pub operator: ApiOverrideOperator,
    pub score: String,
    pub subscore: Option<String>,
}

/// A user with additional account details. Always the current user.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccount {
    pub custom_id: String,
    pub devices: Vec<ApiAccountDevice>,
    pub disable_time: String,
    pub email: String,
    pub user: ApiUser,
    pub verify_time: String,
    pub wallet: String,
}

/// Send a Apple Sign In token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountApple {
    pub token: String,
    pub vars: HashMap<String, String>,
}

/// Send a custom ID to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountCustom {
    pub id: String,
    pub vars: HashMap<String, String>,
}

/// Send a device to the server. Used with authenticate/link/unlink and user.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountDevice {
    pub id: String,
    pub vars: HashMap<String, String>,
}

/// Send an email with password to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountEmail {
    pub email: String,
    pub password: String,
    pub vars: HashMap<String, String>,
}

/// Send a Facebook token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountFacebook {
    pub token: String,
    pub vars: HashMap<String, String>,
}

/// Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountFacebookInstantGame {
    pub signed_player_info: String,
    pub vars: HashMap<String, String>,
}

/// Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountGameCenter {
    pub bundle_id: String,
    pub player_id: String,
    pub public_key_url: String,
    pub salt: String,
    pub signature: String,
    pub timestamp_seconds: String,
    pub vars: HashMap<String, String>,
}

/// Send a Google token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountGoogle {
    pub token: String,
    pub vars: HashMap<String, String>,
}

/// Send a Steam token to the server. Used with authenticate/link/unlink.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiAccountSteam {
    pub token: String,
    pub vars: HashMap<String, String>,
}

/// A message sent on a channel.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiChannelMessage {
    pub channel_id: String,
    pub code: i32,
    pub content: String,
    pub create_time: String,
    pub group_id: String,
    pub message_id: String,
    pub persistent: bool,
    pub room_name: String,
    pub sender_id: String,
    pub update_time: String,
    pub user_id_one: String,
    pub user_id_two: String,
    pub username: String,
}

/// A list of channel messages, usually a result of a list operation.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiChannelMessageList {
    pub cacheable_cursor: String,
    pub messages: Vec<ApiChannelMessage>,
    pub next_cursor: String,
    pub prev_cursor: String,
}

/// Create a group with the current user as owner.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiCreateGroupRequest {
    pub avatar_url: String,
    pub description: String,
    pub lang_tag: String,
    pub max_count: i32,
    pub name: String,
    pub open: bool,
}

/// Storage objects to delete.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiDeleteStorageObjectId {
    pub collection: String,
    pub key: String,
    pub version: String,
}

/// Batch delete storage objects.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiDeleteStorageObjectsRequest {
    pub object_ids: Vec<ApiDeleteStorageObjectId>,
}

/// Represents an event to be passed through the server to registered event handlers.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiEvent {
    pub external: bool,
    pub name: String,
    pub properties: HashMap<String, String>,
    pub timestamp: String,
}

/// A friend of a user.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiFriend {
    pub state: i32,
    pub update_time: String,
    pub user: ApiUser,
}

/// A collection of zero or more friends of the user.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiFriendList {
    pub cursor: String,
    pub friends: Vec<ApiFriend>,
}

/// A group in the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroup {
    pub avatar_url: String,
    pub create_time: String,
    pub creator_id: String,
    pub description: String,
    pub edge_count: i32,
    pub id: String,
    pub lang_tag: String,
    pub max_count: i32,
    pub metadata: String,
    pub name: String,
    pub open: bool,
    pub update_time: String,
}

/// One or more groups returned from a listing operation.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroupList {
    pub cursor: String,
    pub groups: Vec<ApiGroup>,
}

/// A list of users belonging to a group, along with their role.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiGroupUserList {
    pub cursor: String,
    pub group_users: Vec<GroupUserListGroupUser>,
}

/// Represents a complete leaderboard record with all scores and associated metadata.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLeaderboardRecord {
    pub create_time: String,
    pub expiry_time: String,
    pub leaderboard_id: String,
    pub max_num_score: i32,
    pub metadata: String,
    pub num_score: i32,
    pub owner_id: String,
    pub rank: String,
    pub score: String,
    pub subscore: Option<String>,
    pub update_time: String,
    pub username: String,
}

/// A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLeaderboardRecordList {
    pub next_cursor: String,
    pub owner_records: Vec<ApiLeaderboardRecord>,
    pub prev_cursor: String,
    pub records: Vec<ApiLeaderboardRecord>,
}

/// Link Steam to the current user's account.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiLinkSteamRequest {
    pub account: ApiAccountSteam,
    pub sync: bool,
}

/// Represents a realtime match.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiMatch {
    pub authoritative: bool,
    pub handler_name: String,
    pub label: String,
    pub match_id: String,
    pub size: i32,
    pub tick_rate: i32,
}

/// A list of realtime matches.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiMatchList {
    pub matches: Vec<ApiMatch>,
}

/// A notification in the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiNotification {
    pub code: i32,
    pub content: String,
    pub create_time: String,
    pub id: String,
    pub persistent: bool,
    pub sender_id: String,
    pub subject: String,
}

/// A collection of zero or more notifications.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiNotificationList {
    pub cacheable_cursor: String,
    pub notifications: Vec<ApiNotification>,
}

/// Operator that can be used to override the one set in the leaderboard.   - NoOverride: Do not override the leaderboard operator.  - BEST: Override the leaderboard operator with BEST.  - SET: Override the leaderboard operator with SET.  - INCREMENT: Override the leaderboard operator with INCREMENT.  - DECREMENT: Override the leaderboard operator with DECREMENT.
#[derive(Debug, Clone, Copy)]
#[repr(i32)]
pub enum ApiOverrideOperator {
    /// Operator that can be used to override the one set in the leaderboard.
    NoOverride = 0,
    ///
    BEST = 1,
    ///  - NoOverride: Do not override the leaderboard operator.
    SET = 2,
    ///  - BEST: Override the leaderboard operator with BEST.
    INCREMENT = 3,
    ///  - SET: Override the leaderboard operator with SET.
    DECREMENT = 4,
}

impl Display for ApiOverrideOperator {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            ApiOverrideOperator::SET => {
                f.write_str("set")
            }
            ApiOverrideOperator::NoOverride => {
                f.write_str("")
            }
            ApiOverrideOperator::DECREMENT => {
                f.write_str("decr")
            }
            ApiOverrideOperator::BEST => {
                f.write_str("bset")
            }
            ApiOverrideOperator::INCREMENT => {
                f.write_str("incr")
            }
        }
    }
}

/// Storage objects to get.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiReadStorageObjectId {
    pub collection: String,
    pub key: String,
    pub user_id: String,
}

/// Batch get storage objects.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiReadStorageObjectsRequest {
    pub object_ids: Vec<ApiReadStorageObjectId>,
}

/// Execute an Lua function on the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiRpc {
    pub http_key: String,
    pub id: String,
    pub payload: String,
}

/// A user's session used to authenticate messages.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSession {
    pub created: bool,
    pub refresh_token: String,
    pub token: String,
}

/// Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSessionLogoutRequest {
    pub refresh_token: String,
    pub token: String,
}

/// Authenticate against the server with a refresh token.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiSessionRefreshRequest {
    pub token: String,
    pub vars: HashMap<String, String>,
}

/// An object within the storage engine.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObject {
    pub collection: String,
    pub create_time: String,
    pub key: String,
    pub permission_read: i32,
    pub permission_write: i32,
    pub update_time: String,
    pub user_id: String,
    pub value: String,
    pub version: String,
}

/// A storage acknowledgement.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectAck {
    pub collection: String,
    pub key: String,
    pub user_id: String,
    pub version: String,
}

/// Batch of acknowledgements for the storage object write.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectAcks {
    pub acks: Vec<ApiStorageObjectAck>,
}

/// List of storage objects.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjectList {
    pub cursor: String,
    pub objects: Vec<ApiStorageObject>,
}

/// Batch of storage objects.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiStorageObjects {
    pub objects: Vec<ApiStorageObject>,
}

/// A tournament on the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournament {
    pub can_enter: bool,
    pub category: i32,
    pub create_time: String,
    pub description: String,
    pub duration: i32,
    pub end_active: i32,
    pub end_time: String,
    pub id: String,
    pub max_num_score: i32,
    pub max_size: i32,
    pub metadata: String,
    pub next_reset: i32,
    pub size: i32,
    pub sort_order: i32,
    pub start_active: i32,
    pub start_time: String,
    pub title: String,
}

/// A list of tournaments.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournamentList {
    pub cursor: Option<String>,
    pub tournaments: Vec<ApiTournament>,
}

/// A set of tournament records which may be part of a tournament records page or a batch of individual records.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiTournamentRecordList {
    pub next_cursor: Option<String>,
    pub owner_records: Vec<ApiLeaderboardRecord>,
    pub prev_cursor: Option<String>,
    pub records: Vec<ApiLeaderboardRecord>,
}

/// Update a user's account details.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUpdateAccountRequest {
    pub avatar_url: String,
    pub display_name: String,
    pub lang_tag: String,
    pub location: String,
    pub timezone: String,
    pub username: String,
}

/// Update fields in a given group.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUpdateGroupRequest {
    pub avatar_url: String,
    pub description: String,
    pub group_id: String,
    pub lang_tag: String,
    pub name: String,
    pub open: bool,
}

/// A user in the server.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUser {
    pub apple_id: String,
    pub avatar_url: String,
    pub create_time: String,
    pub display_name: String,
    pub edge_count: i32,
    pub facebook_id: String,
    pub facebook_instant_game_id: String,
    pub gamecenter_id: String,
    pub google_id: String,
    pub id: String,
    pub lang_tag: String,
    pub location: String,
    pub metadata: String,
    pub online: bool,
    pub steam_id: String,
    pub timezone: String,
    pub update_time: String,
    pub username: String,
}

/// A list of groups belonging to a user, along with the user's role in each group.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUserGroupList {
    pub cursor: String,
    pub user_groups: Vec<UserGroupListUserGroup>,
}

/// A collection of zero or more users.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiUsers {
    pub users: Vec<ApiUser>,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseAppleRequest {
    pub receipt: String,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseGoogleRequest {
    pub purchase: String,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseHuaweiRequest {
    pub purchase: String,
    pub signature: String,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatePurchaseResponse {
    pub validated_purchases: Vec<ApiValidatedPurchase>,
}

/// Validated Purchase stored by Nakama.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiValidatedPurchase {
    pub create_time: String,
    pub environment: ValidatedPurchaseEnvironment,
    pub product_id: String,
    pub provider_response: String,
    pub purchase_time: String,
    pub store: ValidatedPurchaseStore,
    pub transaction_id: String,
    pub update_time: String,
}

/// The object to store.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiWriteStorageObject {
    pub collection: String,
    pub key: String,
    pub permission_read: i32,
    pub permission_write: i32,
    pub value: String,
    pub version: String,
}

/// Write objects to the storage engine.
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ApiWriteStorageObjectsRequest {
    pub objects: Vec<ApiWriteStorageObject>,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct ProtobufAny {
    pub type_url: String,
    pub value: String,
}

///
#[derive(Debug, DeJson, SerJson, Default, Clone)]
#[nserde(default)]
pub struct RpcStatus {
    pub code: i32,
    pub details: Vec<ProtobufAny>,
    pub message: String,
}

/// A healthcheck which load balancers can use to check the service.
pub fn healthcheck(bearer_token: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/healthcheck".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Fetch the current user's account.
pub fn get_account(bearer_token: &str) -> RestRequest<ApiAccount> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Update fields in the current user's account.
pub fn update_account(bearer_token: &str, body: ApiUpdateAccountRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with an Apple ID against the server.
pub fn authenticate_apple(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountApple,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with a custom id against the server.
pub fn authenticate_custom(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountCustom,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with a device id against the server.
pub fn authenticate_device(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountDevice,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with an email+password against the server.
pub fn authenticate_email(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountEmail,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with a Facebook OAuth token against the server.
pub fn authenticate_facebook(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountFacebook,
    create: Option<bool>,
    username: Option<&str>,
    sync: Option<bool>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with a Facebook Instant Game token against the server.
pub fn authenticate_facebook_instant_game(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountFacebookInstantGame,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with Apple's GameCenter against the server.
pub fn authenticate_game_center(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountGameCenter,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with Google against the server.
pub fn authenticate_google(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountGoogle,
    create: Option<bool>,
    username: Option<&str>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Authenticate a user with Steam against the server.
pub fn authenticate_steam(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiAccountSteam,
    create: Option<bool>,
    username: Option<&str>,
    sync: Option<bool>,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/authenticate/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = create {
        query_params.push_str(&format!("create={:?}&", param));
    }
    if let Some(param) = username {
        query_params.push_str(&format!("username={}&", encode(param)));
    }
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add an Apple ID to the social profiles on the current user's account.
pub fn link_apple(bearer_token: &str, body: ApiAccountApple) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add a custom ID to the social profiles on the current user's account.
pub fn link_custom(bearer_token: &str, body: ApiAccountCustom) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add a device ID to the social profiles on the current user's account.
pub fn link_device(bearer_token: &str, body: ApiAccountDevice) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add an email+password to the social profiles on the current user's account.
pub fn link_email(bearer_token: &str, body: ApiAccountEmail) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add Facebook to the social profiles on the current user's account.
pub fn link_facebook(
    bearer_token: &str,
    body: ApiAccountFacebook,
    sync: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = sync {
        query_params.push_str(&format!("sync={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add Facebook Instant Game to the social profiles on the current user's account.
pub fn link_facebook_instant_game(
    bearer_token: &str,
    body: ApiAccountFacebookInstantGame,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add Apple's GameCenter to the social profiles on the current user's account.
pub fn link_game_center(bearer_token: &str, body: ApiAccountGameCenter) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add Google to the social profiles on the current user's account.
pub fn link_google(bearer_token: &str, body: ApiAccountGoogle) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add Steam to the social profiles on the current user's account.
pub fn link_steam(bearer_token: &str, body: ApiLinkSteamRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/link/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Refresh a user's session using a refresh token retrieved from a previous authentication request.
pub fn session_refresh(
    basic_auth_username: &str,
    basic_auth_password: &str,
    body: ApiSessionRefreshRequest,
) -> RestRequest<ApiSession> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/session/refresh".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Basic {
        username: basic_auth_username.to_owned(),
        password: basic_auth_password.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove the Apple ID from the social profiles on the current user's account.
pub fn unlink_apple(bearer_token: &str, body: ApiAccountApple) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove the custom ID from the social profiles on the current user's account.
pub fn unlink_custom(bearer_token: &str, body: ApiAccountCustom) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/custom".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove the device ID from the social profiles on the current user's account.
pub fn unlink_device(bearer_token: &str, body: ApiAccountDevice) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/device".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove the email+password from the social profiles on the current user's account.
pub fn unlink_email(bearer_token: &str, body: ApiAccountEmail) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/email".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove Facebook from the social profiles on the current user's account.
pub fn unlink_facebook(bearer_token: &str, body: ApiAccountFacebook) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove Facebook Instant Game profile from the social profiles on the current user's account.
pub fn unlink_facebook_instant_game(
    bearer_token: &str,
    body: ApiAccountFacebookInstantGame,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/facebookinstantgame".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove Apple's GameCenter from the social profiles on the current user's account.
pub fn unlink_game_center(bearer_token: &str, body: ApiAccountGameCenter) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/gamecenter".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove Google from the social profiles on the current user's account.
pub fn unlink_google(bearer_token: &str, body: ApiAccountGoogle) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Remove Steam from the social profiles on the current user's account.
pub fn unlink_steam(bearer_token: &str, body: ApiAccountSteam) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/account/unlink/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List a channel's message history.
pub fn list_channel_messages(
    bearer_token: &str,
    channel_id: &str,
    limit: Option<i32>,
    forward: Option<bool>,
    cursor: Option<&str>,
) -> RestRequest<ApiChannelMessageList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/channel/{channelId}".to_string();
    urlpath = urlpath.replace("{channelId}", channel_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = forward {
        query_params.push_str(&format!("forward={:?}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Submit an event for processing in the server's registered runtime custom events handler.
pub fn event(bearer_token: &str, body: ApiEvent) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/event".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Delete one or more users by ID or username.
pub fn delete_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={}&", encode(elem)));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List all friends for the current user.
pub fn list_friends(
    bearer_token: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiFriendList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add friends by ID or username to a user's account.
pub fn add_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={}&", encode(elem)));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Block one or more users by ID or username.
pub fn block_friends(bearer_token: &str, ids: &[String], usernames: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/block".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={}&", encode(elem)));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Import Facebook friends and add them to a user's account.
pub fn import_facebook_friends(
    bearer_token: &str,
    body: ApiAccountFacebook,
    reset: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/facebook".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = reset {
        query_params.push_str(&format!("reset={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Import Steam friends and add them to a user's account.
pub fn import_steam_friends(
    bearer_token: &str,
    body: ApiAccountSteam,
    reset: Option<bool>,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/friend/steam".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = reset {
        query_params.push_str(&format!("reset={:?}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List groups based on given filters.
pub fn list_groups(
    bearer_token: &str,
    name: Option<&str>,
    cursor: Option<&str>,
    limit: Option<i32>,
) -> RestRequest<ApiGroupList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = name {
        query_params.push_str(&format!("name={}&", encode(param)));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Create a new group with the current user as the owner.
pub fn create_group(bearer_token: &str, body: ApiCreateGroupRequest) -> RestRequest<ApiGroup> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Delete a group by ID.
pub fn delete_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Update fields in a given group.
pub fn update_group(
    bearer_token: &str,
    group_id: &str,
    body: ApiUpdateGroupRequest,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Add users to a group.
pub fn add_group_users(bearer_token: &str, group_id: &str, user_ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/add".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Ban a set of users from a group.
pub fn ban_group_users(bearer_token: &str, group_id: &str, user_ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/ban".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Demote a set of users in a group to the next role down.
pub fn demote_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/demote".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Immediately join an open group, or request to join a closed one.
pub fn join_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/join".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Kick a set of users from a group.
pub fn kick_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/kick".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Leave a group the user is a member of.
pub fn leave_group(bearer_token: &str, group_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/leave".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Promote a set of users in a group to the next role up.
pub fn promote_group_users(
    bearer_token: &str,
    group_id: &str,
    user_ids: &[String],
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/promote".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in user_ids {
        query_params.push_str(&format!("user_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List all users that are part of a group.
pub fn list_group_users(
    bearer_token: &str,
    group_id: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiGroupUserList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/group/{groupId}/user".to_string();
    urlpath = urlpath.replace("{groupId}", group_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Validate Apple IAP Receipt
pub fn validate_purchase_apple(
    bearer_token: &str,
    body: ApiValidatePurchaseAppleRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/apple".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Validate Google IAP Receipt
pub fn validate_purchase_google(
    bearer_token: &str,
    body: ApiValidatePurchaseGoogleRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/google".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Validate Huawei IAP Receipt
pub fn validate_purchase_huawei(
    bearer_token: &str,
    body: ApiValidatePurchaseHuaweiRequest,
) -> RestRequest<ApiValidatePurchaseResponse> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/iap/purchase/huawei".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Delete a leaderboard record.
pub fn delete_leaderboard_record(bearer_token: &str, leaderboard_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List leaderboard records.
pub fn list_leaderboard_records(
    bearer_token: &str,
    leaderboard_id: &str,
    owner_ids: &[String],
    limit: Option<i32>,
    cursor: Option<&str>,
    expiry: Option<&str>,
) -> RestRequest<ApiLeaderboardRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in owner_ids {
        query_params.push_str(&format!("owner_ids={}&", encode(elem)));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Write a record to a leaderboard.
pub fn write_leaderboard_record(
    bearer_token: &str,
    leaderboard_id: &str,
    body: WriteLeaderboardRecordRequestLeaderboardRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Create a leaderboard.
pub fn create_leaderboard(
    bearer_token: &str,
    body: CreateLeaderboard,
) -> RestRequest<CreateLeaderboardRes> {
    #[allow(unused_mut)]
    let urlpath = "/v2/rpc/clientrpc.create_leaderboard".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = format!("{:?}", body.serialize_json());
    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List leaderboard records that belong to a user.
pub fn list_leaderboard_records_around_owner(
    bearer_token: &str,
    leaderboard_id: &str,
    owner_id: &str,
    limit: Option<i32>,
    expiry: Option<&str>,
) -> RestRequest<ApiLeaderboardRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}".to_string();
    urlpath = urlpath.replace("{leaderboardId}", leaderboard_id);
    urlpath = urlpath.replace("{ownerId}", owner_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Fetch list of running matches.
pub fn list_matches(
    bearer_token: &str,
    limit: Option<i32>,
    authoritative: Option<bool>,
    label: Option<&str>,
    min_size: Option<i32>,
    max_size: Option<i32>,
    query: Option<&str>,
) -> RestRequest<ApiMatchList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/match".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = authoritative {
        query_params.push_str(&format!("authoritative={:?}&", param));
    }
    if let Some(param) = label {
        query_params.push_str(&format!("label={}&", encode(param)));
    }
    if let Some(param) = min_size {
        query_params.push_str(&format!("min_size={}&", param));
    }
    if let Some(param) = max_size {
        query_params.push_str(&format!("max_size={}&", param));
    }
    if let Some(param) = query {
        query_params.push_str(&format!("query={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Delete one or more notifications for the current user.
pub fn delete_notifications(bearer_token: &str, ids: &[String]) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/notification".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Delete;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Fetch list of notifications.
pub fn list_notifications(
    bearer_token: &str,
    limit: Option<i32>,
    cacheable_cursor: Option<&str>,
) -> RestRequest<ApiNotificationList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/notification".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cacheable_cursor {
        query_params.push_str(&format!("cacheable_cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Execute a Lua function on the server.
pub fn rpc_func2(
    bearer_token: &str,
    id: &str,
    payload: Option<&str>,
    http_key: Option<&str>,
) -> RestRequest<ApiRpc> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/rpc/{id}".to_string();
    urlpath = urlpath.replace("{id}", id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = payload {
        query_params.push_str(&format!("payload={}&", encode(param)));
    }
    if let Some(param) = http_key {
        query_params.push_str(&format!("http_key={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Execute a Lua function on the server.
pub fn rpc_func(
    bearer_token: &str,
    id: &str,
    body: &str,
    http_key: Option<&str>,
) -> RestRequest<ApiRpc> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/rpc/{id}".to_string();
    urlpath = urlpath.replace("{id}", id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = http_key {
        query_params.push_str(&format!("http_key={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.to_string();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user.
pub fn session_logout(bearer_token: &str, body: ApiSessionLogoutRequest) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/session/logout".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Get storage objects.
pub fn read_storage_objects(
    bearer_token: &str,
    body: ApiReadStorageObjectsRequest,
) -> RestRequest<ApiStorageObjects> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Write objects into the storage engine.
pub fn write_storage_objects(
    bearer_token: &str,
    body: ApiWriteStorageObjectsRequest,
) -> RestRequest<ApiStorageObjectAcks> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Delete one or more objects by ID or username.
pub fn delete_storage_objects(
    bearer_token: &str,
    body: ApiDeleteStorageObjectsRequest,
) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/delete".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List publicly readable storage objects in a given collection.
pub fn list_storage_objects(
    bearer_token: &str,
    collection: &str,
    user_id: Option<&str>,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiStorageObjectList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/{collection}".to_string();
    urlpath = urlpath.replace("{collection}", collection);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = user_id {
        query_params.push_str(&format!("user_id={}&", encode(param)));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List publicly readable storage objects in a given collection.
pub fn list_storage_objects2(
    bearer_token: &str,
    collection: &str,
    user_id: &str,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiStorageObjectList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/storage/{collection}/{userId}".to_string();
    urlpath = urlpath.replace("{collection}", collection);
    urlpath = urlpath.replace("{userId}", user_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List current or upcoming tournaments.
pub fn list_tournaments(
    bearer_token: &str,
    category_start: Option<i32>,
    category_end: Option<i32>,
    start_time: Option<i32>,
    end_time: Option<i32>,
    limit: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiTournamentList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = category_start {
        query_params.push_str(&format!("category_start={}&", param));
    }
    if let Some(param) = category_end {
        query_params.push_str(&format!("category_end={}&", param));
    }
    if let Some(param) = start_time {
        query_params.push_str(&format!("start_time={}&", param));
    }
    if let Some(param) = end_time {
        query_params.push_str(&format!("end_time={}&", param));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List tournament records.
pub fn list_tournament_records(
    bearer_token: &str,
    tournament_id: &str,
    owner_ids: &[String],
    limit: Option<i32>,
    cursor: Option<&str>,
    expiry: Option<&str>,
) -> RestRequest<ApiTournamentRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in owner_ids {
        query_params.push_str(&format!("owner_ids={}&", encode(elem)));
    }
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Write a record to a tournament.
pub fn write_tournament_record2(
    bearer_token: &str,
    tournament_id: &str,
    body: WriteTournamentRecordRequestTournamentRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Write a record to a tournament.
pub fn write_tournament_record(
    bearer_token: &str,
    tournament_id: &str,
    body: WriteTournamentRecordRequestTournamentRecordWrite,
) -> RestRequest<ApiLeaderboardRecord> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };
    let body_json = body.serialize_json();

    let method = Method::Put;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Attempt to join an open and running tournament.
pub fn join_tournament(bearer_token: &str, tournament_id: &str) -> RestRequest<()> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}/join".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Post;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List tournament records for a given owner.
pub fn list_tournament_records_around_owner(
    bearer_token: &str,
    tournament_id: &str,
    owner_id: &str,
    limit: Option<i32>,
    expiry: Option<&str>,
) -> RestRequest<ApiTournamentRecordList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/tournament/{tournamentId}/owner/{ownerId}".to_string();
    urlpath = urlpath.replace("{tournamentId}", tournament_id);
    urlpath = urlpath.replace("{ownerId}", owner_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = expiry {
        query_params.push_str(&format!("expiry={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// Fetch zero or more users by ID and/or username.
pub fn get_users(
    bearer_token: &str,
    ids: &[String],
    usernames: &[String],
    facebook_ids: &[String],
) -> RestRequest<ApiUsers> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/user".to_string();

    #[allow(unused_mut)]
    let mut query_params = String::new();
    for elem in ids {
        query_params.push_str(&format!("ids={}&", encode(elem)));
    }
    for elem in usernames {
        query_params.push_str(&format!("usernames={}&", encode(elem)));
    }
    for elem in facebook_ids {
        query_params.push_str(&format!("facebook_ids={}&", encode(elem)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}

/// List groups the current user belongs to.
pub fn list_user_groups(
    bearer_token: &str,
    user_id: &str,
    limit: Option<i32>,
    state: Option<i32>,
    cursor: Option<&str>,
) -> RestRequest<ApiUserGroupList> {
    #[allow(unused_mut)]
    let mut urlpath = "/v2/user/{userId}/group".to_string();
    urlpath = urlpath.replace("{userId}", user_id);

    #[allow(unused_mut)]
    let mut query_params = String::new();
    if let Some(param) = limit {
        query_params.push_str(&format!("limit={}&", param));
    }
    if let Some(param) = state {
        query_params.push_str(&format!("state={}&", param));
    }
    if let Some(param) = cursor {
        query_params.push_str(&format!("cursor={}&", encode(param)));
    }

    let authentication = Authentication::Bearer {
        token: bearer_token.to_owned(),
    };

    let body_json = String::new();

    let method = Method::Get;

    RestRequest {
        authentication,
        urlpath,
        query_params,
        body: body_json,
        method,
        _marker: std::marker::PhantomData,
    }
}
